// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE
'use strict';

var Curry      = require("bs-platform/lib/js/curry.js");
var Utils      = require("../utils.js");
var Caml_obj   = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

function raw_to_vertex(a, b, s) {
  var res = 0;
  var v = 0;
  for(var y = 0 ,y_finish = s - 1 | 0; y <= y_finish; ++y){
    for(var x = 0 ,x_finish = (s - y | 0) - 1 | 0; x <= x_finish; ++x){
      if (x === a && y === b) {
        res = v;
      }
      v = v + 1 | 0;
    }
  }
  return res;
}

function to_vertex(size, param) {
  var y = param[1];
  var x = param[0];
  var match = +(x < 0 || y < 0 || x > size || y > size || (x + y | 0) >= size);
  if (match !== 0) {
    return /* None */0;
  } else {
    return /* Some */[raw_to_vertex(x, y, size)];
  }
}

function find(arr, x) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (Caml_obj.caml_equal(Caml_array.caml_array_get(arr, i), x)) {
      return /* Some */[i];
    } else if (i > arr.length) {
      return /* None */0;
    } else {
      _i = i + 1 | 0;
      continue ;
      
    }
  };
}

function from_vertex(size, vertex) {
  var res = /* tuple */[
    0,
    0
  ];
  var i = 0;
  for(var y = 0 ,y_finish = size - 1 | 0; y <= y_finish; ++y){
    for(var x = 0 ,x_finish = (size - y | 0) - 1 | 0; x <= x_finish; ++x){
      if (vertex === i) {
        res = /* tuple */[
          x,
          y
        ];
      }
      i = i + 1 | 0;
    }
  }
  return res;
}

function vertex_count(size) {
  return Caml_int32.imul(size, size + 1 | 0) / 2 | 0;
}

function all_coordinates(size) {
  var res = Caml_array.caml_make_vect(vertex_count(size), /* tuple */[
        0,
        0
      ]);
  var i = 0;
  for(var y = 0 ,y_finish = size - 1 | 0; y <= y_finish; ++y){
    for(var x = 0 ,x_finish = (size - y | 0) - 1 | 0; x <= x_finish; ++x){
      Caml_array.caml_array_set(res, i, /* tuple */[
            x,
            y
          ]);
      i = i + 1 | 0;
    }
  }
  return res;
}

function fi(prim) {
  return prim;
}

function coord_to_board(size, param, param$1) {
  var w = param[0];
  var height = Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* / */2], w, 2.0), Math.sqrt(3.0));
  var sx = Curry._2(Utils.Float[/* / */2], Curry._2(Utils.Float[/* / */2], w, size), 2.0);
  var sy = Curry._2(Utils.Float[/* / */2], height, size);
  var match_000 = param$1[0];
  var match_001 = param$1[1];
  var fy = match_001;
  var fx = match_000;
  var dx = Curry._2(Utils.Float[/* - */1], Curry._2(Utils.Float[/* * */3], sx, fx), Curry._2(Utils.Float[/* * */3], sx, fy));
  var dy = Curry._2(Utils.Float[/* + */0], Curry._2(Utils.Float[/* * */3], sy, fx), Curry._2(Utils.Float[/* * */3], sy, fy));
  return /* tuple */[
          Curry._2(Utils.Float[/* + */0], dx, Curry._2(Utils.Float[/* / */2], w, 2.0)),
          Curry._2(Utils.Float[/* + */0], dy, Curry._2(Utils.Float[/* / */2], Curry._2(Utils.Float[/* - */1], param[1], height), 2.0))
        ];
}

function scale(size, param) {
  return param[0] / size;
}

function border_walls(size) {
  var res = /* [] */0;
  for(var x = 0 ,x_finish = size - 1 | 0; x <= x_finish; ++x){
    res = /* :: */[
      /* tuple */[
        /* tuple */[
          x,
          0
        ],
        /* Yminus */2
      ],
      /* :: */[
        /* tuple */[
          /* tuple */[
            x,
            0
          ],
          /* Zx */4
        ],
        res
      ]
    ];
  }
  for(var y = 0 ,y_finish = size - 1 | 0; y <= y_finish; ++y){
    res = /* :: */[
      /* tuple */[
        /* tuple */[
          0,
          y
        ],
        /* Xminus */0
      ],
      /* :: */[
        /* tuple */[
          /* tuple */[
            0,
            y
          ],
          /* Zy */5
        ],
        res
      ]
    ];
  }
  for(var x$1 = 0 ,x_finish$1 = size - 1 | 0; x$1 <= x_finish$1; ++x$1){
    var y$1 = (size - 1 | 0) - x$1 | 0;
    res = /* :: */[
      /* tuple */[
        /* tuple */[
          x$1,
          y$1
        ],
        /* Yplus */3
      ],
      /* :: */[
        /* tuple */[
          /* tuple */[
            x$1,
            y$1
          ],
          /* Xplus */1
        ],
        res
      ]
    ];
  }
  return res;
}

var Tile = 0;

exports.Tile            = Tile;
exports.raw_to_vertex   = raw_to_vertex;
exports.to_vertex       = to_vertex;
exports.find            = find;
exports.from_vertex     = from_vertex;
exports.vertex_count    = vertex_count;
exports.all_coordinates = all_coordinates;
exports.fi              = fi;
exports.coord_to_board  = coord_to_board;
exports.scale           = scale;
exports.border_walls    = border_walls;
/* No side effect */
