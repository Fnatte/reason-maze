// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE
'use strict';

var List       = require("bs-platform/lib/js/list.js");
var Curry      = require("bs-platform/lib/js/curry.js");
var Utils      = require("../utils.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

function vertex(param) {
  return param[0] + Caml_int32.imul(param[1], param[2]) | 0;
}

function from_vertex(v, w) {
  return /* tuple */[
          Caml_int32.mod_(v, w),
          Caml_int32.div(v, w)
        ];
}

function vertex_count(param) {
  return Caml_int32.imul(param[0], param[1]);
}

function direction_to(param, param$1) {
  var b = param$1[1];
  var a = param$1[0];
  var y = param[1];
  var x = param[0];
  var match = +((x + 1 | 0) === a);
  if (match !== 0) {
    return /* Right */3;
  } else {
    var match$1 = +((x - 1 | 0) === a);
    if (match$1 !== 0) {
      return /* Left */2;
    } else {
      var match$2 = +((y - 1 | 0) === b);
      if (match$2 !== 0) {
        return /* Up */0;
      } else {
        var match$3 = +((y + 1 | 0) === b);
        if (match$3 !== 0) {
          return /* Down */1;
        } else {
          return /* Left */2;
        }
      }
    }
  }
}

function points_to_line(p1, p2, param, param$1) {
  var dx = param$1[0] / param[0];
  var dy = param$1[1] / param[1];
  var fx = p1[0];
  var fy = p1[1];
  var match = direction_to(p1, p2);
  var pts;
  switch (match) {
    case 0 : 
        pts = /* tuple */[
          /* tuple */[
            Curry._2(Utils.Float[/* * */3], fx, dx),
            Curry._2(Utils.Float[/* * */3], fy, dy)
          ],
          /* tuple */[
            Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* + */0], fx, 1.0), dx),
            Curry._2(Utils.Float[/* * */3], fy, dy)
          ]
        ];
        break;
    case 1 : 
        pts = /* tuple */[
          /* tuple */[
            Curry._2(Utils.Float[/* * */3], fx, dx),
            Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* + */0], fy, 1.0), dy)
          ],
          /* tuple */[
            Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* + */0], fx, 1.0), dx),
            Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* + */0], fy, 1.0), dy)
          ]
        ];
        break;
    case 2 : 
        pts = /* tuple */[
          /* tuple */[
            Curry._2(Utils.Float[/* * */3], fx, dx),
            Curry._2(Utils.Float[/* * */3], fy, dy)
          ],
          /* tuple */[
            Curry._2(Utils.Float[/* * */3], fx, dx),
            Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* + */0], fy, 1.0), dy)
          ]
        ];
        break;
    case 3 : 
        pts = /* tuple */[
          /* tuple */[
            Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* + */0], fx, 1.0), dx),
            Curry._2(Utils.Float[/* * */3], fy, dy)
          ],
          /* tuple */[
            Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* + */0], fx, 1.0), dx),
            Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* + */0], fy, 1.0), dy)
          ]
        ];
        break;
    
  }
  return /* Line */[pts];
}

function adjacent_to(x, y, w, h) {
  var match = +(x === 0);
  var a = match !== 0 ? /* [] */0 : /* :: */[
      /* tuple */[
        x - 1 | 0,
        y
      ],
      /* [] */0
    ];
  var match$1 = +(y === 0);
  var a$1 = match$1 !== 0 ? a : /* :: */[
      /* tuple */[
        x,
        y - 1 | 0
      ],
      a
    ];
  var match$2 = +(x >= (w - 1 | 0));
  var a$2 = match$2 !== 0 ? a$1 : /* :: */[
      /* tuple */[
        x + 1 | 0,
        y
      ],
      a$1
    ];
  var match$3 = +(y >= (h - 1 | 0));
  if (match$3 !== 0) {
    return a$2;
  } else {
    return /* :: */[
            /* tuple */[
              x,
              y + 1 | 0
            ],
            a$2
          ];
  }
}

function adjacency_list(param) {
  var h = param[1];
  var w = param[0];
  var v = Caml_array.caml_make_vect(Caml_int32.imul(w, h), /* [] */0);
  for(var x = 0 ,x_finish = w - 1 | 0; x <= x_finish; ++x){
    for(var y = 0 ,y_finish = h - 1 | 0; y <= y_finish; ++y){
      Caml_array.caml_array_set(v, vertex(/* tuple */[
                x,
                y,
                w
              ]), List.map(function (param) {
                return vertex(/* tuple */[
                            param[0],
                            param[1],
                            w
                          ]);
              }, adjacent_to(x, y, w, h)));
    }
  }
  return v;
}

function border_walls(_, _$1) {
  return /* [] */0;
}

function drawable_wall(param, param$1, osize) {
  var w = param$1[0];
  return points_to_line(from_vertex(param[0], w), from_vertex(param[1], w), /* tuple */[
              w,
              param$1[1]
            ], osize);
}

function point_in_place(param, param$1, param$2) {
  var dx = Curry._2(Utils.Float[/* / */2], param$2[0], param$1[0]);
  var dy = Curry._2(Utils.Float[/* / */2], param$2[1], param$1[1]);
  var fx = param[0];
  var fy = param[1];
  return /* tuple */[
          Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* + */0], fx, 0.5), dx),
          Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* + */0], fy, 0.5), dy)
        ];
}

function vertex_pos(v, param, osize) {
  var w = param[0];
  var p = from_vertex(v, w);
  return point_in_place(p, /* tuple */[
              w,
              param[1]
            ], osize);
}

exports.vertex         = vertex;
exports.from_vertex    = from_vertex;
exports.vertex_count   = vertex_count;
exports.direction_to   = direction_to;
exports.points_to_line = points_to_line;
exports.adjacent_to    = adjacent_to;
exports.adjacency_list = adjacency_list;
exports.border_walls   = border_walls;
exports.drawable_wall  = drawable_wall;
exports.point_in_place = point_in_place;
exports.vertex_pos     = vertex_pos;
/* No side effect */
