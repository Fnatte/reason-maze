// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE
'use strict';

var $$Array    = require("bs-platform/lib/js/array.js");
var Curry      = require("bs-platform/lib/js/curry.js");
var Utils      = require("../utils.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

function from_vertex(param, v) {
  var w = param[0];
  return /* tuple */[
          Caml_int32.mod_(v, w),
          Caml_int32.div(v, w)
        ];
}

function vertex_count(param) {
  return Caml_int32.imul(param[0], param[1]);
}

function in_bounds(param, param$1) {
  var y = param$1[1];
  var x = param$1[0];
  if (x < param[0] && y < param[1] && x >= 0) {
    return +(y >= 0);
  } else {
    return /* false */0;
  }
}

function to_vertex(param, param$1) {
  var y = param$1[1];
  var x = param$1[0];
  var w = param[0];
  if (in_bounds(/* tuple */[
          w,
          param[1]
        ], /* tuple */[
          x,
          y
        ])) {
    return /* Some */[x + Caml_int32.imul(y, w) | 0];
  } else {
    return /* None */0;
  }
}

function all_coordinates(param) {
  var h = param[1];
  var w = param[0];
  var inner = function (_x, _y) {
    while(true) {
      var y = _y;
      var x = _x;
      if (x >= w) {
        _y = y + 1 | 0;
        _x = 0;
        continue ;
        
      } else if (y >= h) {
        return /* [] */0;
      } else {
        return /* :: */[
                /* tuple */[
                  x,
                  y
                ],
                inner(x + 1 | 0, y)
              ];
      }
    };
  };
  return $$Array.of_list(inner(0, 0));
}

function fi(prim) {
  return prim;
}

function coord_to_board(param, param$1, param$2) {
  var dx = Curry._2(Utils.Float[/* / */2], param$1[0], param[0]);
  var dy = Curry._2(Utils.Float[/* / */2], param$1[1], param[1]);
  return /* tuple */[
          Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* + */0], param$2[0], 0.5), dx),
          Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* + */0], param$2[1], 0.5), dy)
        ];
}

function scale(param, param$1) {
  return param$1[0] / param[0];
}

function border_walls() {
  return /* [] */0;
}

var Tile = 0;

exports.from_vertex     = from_vertex;
exports.vertex_count    = vertex_count;
exports.Tile            = Tile;
exports.in_bounds       = in_bounds;
exports.to_vertex       = to_vertex;
exports.all_coordinates = all_coordinates;
exports.fi              = fi;
exports.coord_to_board  = coord_to_board;
exports.scale           = scale;
exports.border_walls    = border_walls;
/* No side effect */
