// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE
'use strict';

var List       = require("bs-platform/lib/js/list.js");
var Curry      = require("bs-platform/lib/js/curry.js");
var Utils      = require("../utils.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

function vertex_count(size) {
  return Caml_int32.imul(size, size + 1 | 0) / 2 | 0;
}

function from_vertex(v, s) {
  var res = /* tuple */[
    0,
    0
  ];
  var i = 0;
  for(var y = 0 ,y_finish = s - 1 | 0; y <= y_finish; ++y){
    for(var x = 0 ,x_finish = (s - y | 0) - 1 | 0; x <= x_finish; ++x){
      if (v === i) {
        res = /* tuple */[
          x,
          y
        ];
      }
      i = i + 1 | 0;
    }
  }
  return res;
}

function to_vertex(a, b, s) {
  var res = 0;
  var v = 0;
  for(var y = 0 ,y_finish = s - 1 | 0; y <= y_finish; ++y){
    for(var x = 0 ,x_finish = (s - y | 0) - 1 | 0; x <= x_finish; ++x){
      if (x === a && y === b) {
        res = v;
      }
      v = v + 1 | 0;
    }
  }
  return res;
}

function maybe_vertex(size, param) {
  var y = param[1];
  var x = param[0];
  var match = +(x < 0 || y < 0 || x > size || y > size || (x + y | 0) >= size);
  if (match !== 0) {
    return /* None */0;
  } else {
    return /* Some */[to_vertex(x, y, size)];
  }
}

function optmap(fn, lst) {
  return List.fold_left(function (res, v) {
              var match = Curry._1(fn, v);
              if (match) {
                return /* :: */[
                        match[0],
                        res
                      ];
              } else {
                return res;
              }
            }, /* [] */0, lst);
}

function adjacency_list(size) {
  var v = Caml_array.caml_make_vect(vertex_count(size), /* [] */0);
  for(var x = 0 ,x_finish = size - 1 | 0; x <= x_finish; ++x){
    for(var y = 0 ,y_finish = (size - x | 0) - 1 | 0; y <= y_finish; ++y){
      var neighbors_000 = /* tuple */[
        x - 1 | 0,
        y
      ];
      var neighbors_001 = /* :: */[
        /* tuple */[
          x + 1 | 0,
          y
        ],
        /* :: */[
          /* tuple */[
            x,
            y - 1 | 0
          ],
          /* :: */[
            /* tuple */[
              x,
              y + 1 | 0
            ],
            /* :: */[
              /* tuple */[
                x - 1 | 0,
                y + 1 | 0
              ],
              /* :: */[
                /* tuple */[
                  x + 1 | 0,
                  y - 1 | 0
                ],
                /* [] */0
              ]
            ]
          ]
        ]
      ];
      var neighbors = /* :: */[
        neighbors_000,
        neighbors_001
      ];
      var connections = optmap(function (param) {
            return maybe_vertex(size, param);
          }, neighbors);
      Caml_array.caml_array_set(v, to_vertex(x, y, size), connections);
    }
  }
  return v;
}

function fi(prim) {
  return prim;
}

function point_pos(param, size, param$1) {
  var w = param$1[0];
  var height = Curry._2(Utils.Float[/* * */3], Curry._2(Utils.Float[/* / */2], w, 2.0), Math.sqrt(3.0));
  var sx = Curry._2(Utils.Float[/* / */2], Curry._2(Utils.Float[/* / */2], w, size), 2.0);
  var sy = Curry._2(Utils.Float[/* / */2], height, size);
  var match_000 = param[0];
  var match_001 = param[1];
  var fy = match_001;
  var fx = match_000;
  var dx = Curry._2(Utils.Float[/* - */1], Curry._2(Utils.Float[/* * */3], sx, fx), Curry._2(Utils.Float[/* * */3], sx, fy));
  var dy = Curry._2(Utils.Float[/* + */0], Curry._2(Utils.Float[/* * */3], sy, fx), Curry._2(Utils.Float[/* * */3], sy, fy));
  return /* tuple */[
          Curry._2(Utils.Float[/* + */0], dx, Curry._2(Utils.Float[/* / */2], w, 2.0)),
          Curry._2(Utils.Float[/* + */0], dy, Curry._2(Utils.Float[/* / */2], Curry._2(Utils.Float[/* - */1], param$1[1], height), 2.0))
        ];
}

function vertex_pos(v, size, param) {
  var match = from_vertex(v, size);
  return point_pos(/* tuple */[
              match[0],
              match[1]
            ], size, /* tuple */[
              param[0],
              param[1]
            ]);
}

function direction_of_points(src, dest, param, param$1) {
  var b = param$1[1];
  var a = param$1[0];
  var y = param[1];
  var x = param[0];
  if ((x + 1 | 0) === a && (y - 1 | 0) === b) {
    return /* Zx */4;
  } else if ((x - 1 | 0) === a && (y + 1 | 0) === b) {
    return /* Zy */5;
  } else if ((x + 1 | 0) === a && y === b) {
    return /* Xplus */1;
  } else if ((x - 1 | 0) === a && y === b) {
    return /* Xminus */0;
  } else if ((y + 1 | 0) === b && x === a) {
    return /* Yplus */3;
  } else if ((y - 1 | 0) === b && x === a) {
    return /* Yminus */2;
  } else {
    console.log(/* tuple */[
          "bad dir",
          x,
          y,
          a,
          b,
          src,
          dest
        ]);
    return /* Zx */4;
  }
}

var sq3 = Math.sqrt(3.0);

function wall_in_direction(fx, fy, u, direction) {
  switch (direction) {
    case 0 : 
        return /* tuple */[
                /* tuple */[
                  fx,
                  Curry._2(Utils.Float[/* - */1], fy, Curry._2(Utils.Float[/* / */2], u, sq3))
                ],
                /* tuple */[
                  Curry._2(Utils.Float[/* - */1], fx, Curry._2(Utils.Float[/* / */2], u, 2.0)),
                  Curry._2(Utils.Float[/* + */0], Curry._2(Utils.Float[/* - */1], fy, Curry._2(Utils.Float[/* / */2], Curry._2(Utils.Float[/* * */3], u, sq3), 2.0)), Curry._2(Utils.Float[/* / */2], u, sq3))
                ]
              ];
    case 1 : 
        return /* tuple */[
                /* tuple */[
                  fx,
                  Curry._2(Utils.Float[/* + */0], fy, Curry._2(Utils.Float[/* / */2], u, sq3))
                ],
                /* tuple */[
                  Curry._2(Utils.Float[/* + */0], fx, Curry._2(Utils.Float[/* / */2], u, 2.0)),
                  Curry._2(Utils.Float[/* - */1], Curry._2(Utils.Float[/* + */0], fy, Curry._2(Utils.Float[/* / */2], Curry._2(Utils.Float[/* * */3], u, sq3), 2.0)), Curry._2(Utils.Float[/* / */2], u, sq3))
                ]
              ];
    case 2 : 
        return /* tuple */[
                /* tuple */[
                  fx,
                  Curry._2(Utils.Float[/* - */1], fy, Curry._2(Utils.Float[/* / */2], u, sq3))
                ],
                /* tuple */[
                  Curry._2(Utils.Float[/* + */0], fx, Curry._2(Utils.Float[/* / */2], u, 2.0)),
                  Curry._2(Utils.Float[/* + */0], Curry._2(Utils.Float[/* - */1], fy, Curry._2(Utils.Float[/* / */2], Curry._2(Utils.Float[/* * */3], u, sq3), 2.0)), Curry._2(Utils.Float[/* / */2], u, sq3))
                ]
              ];
    case 3 : 
        return /* tuple */[
                /* tuple */[
                  fx,
                  Curry._2(Utils.Float[/* + */0], fy, Curry._2(Utils.Float[/* / */2], u, sq3))
                ],
                /* tuple */[
                  Curry._2(Utils.Float[/* - */1], fx, Curry._2(Utils.Float[/* / */2], u, 2.0)),
                  Curry._2(Utils.Float[/* - */1], Curry._2(Utils.Float[/* + */0], fy, Curry._2(Utils.Float[/* / */2], Curry._2(Utils.Float[/* * */3], u, sq3), 2.0)), Curry._2(Utils.Float[/* / */2], u, sq3))
                ]
              ];
    case 4 : 
        return /* tuple */[
                /* tuple */[
                  Curry._2(Utils.Float[/* + */0], fx, Curry._2(Utils.Float[/* / */2], u, 2.0)),
                  Curry._2(Utils.Float[/* - */1], Curry._2(Utils.Float[/* + */0], fy, Curry._2(Utils.Float[/* / */2], Curry._2(Utils.Float[/* * */3], u, sq3), 2.0)), Curry._2(Utils.Float[/* / */2], u, sq3))
                ],
                /* tuple */[
                  Curry._2(Utils.Float[/* + */0], fx, Curry._2(Utils.Float[/* / */2], u, 2.0)),
                  Curry._2(Utils.Float[/* + */0], Curry._2(Utils.Float[/* - */1], fy, Curry._2(Utils.Float[/* / */2], Curry._2(Utils.Float[/* * */3], u, sq3), 2.0)), Curry._2(Utils.Float[/* / */2], u, sq3))
                ]
              ];
    case 5 : 
        return /* tuple */[
                /* tuple */[
                  Curry._2(Utils.Float[/* - */1], fx, Curry._2(Utils.Float[/* / */2], u, 2.0)),
                  Curry._2(Utils.Float[/* - */1], Curry._2(Utils.Float[/* + */0], fy, Curry._2(Utils.Float[/* / */2], Curry._2(Utils.Float[/* * */3], u, sq3), 2.0)), Curry._2(Utils.Float[/* / */2], u, sq3))
                ],
                /* tuple */[
                  Curry._2(Utils.Float[/* - */1], fx, Curry._2(Utils.Float[/* / */2], u, 2.0)),
                  Curry._2(Utils.Float[/* + */0], Curry._2(Utils.Float[/* - */1], fy, Curry._2(Utils.Float[/* / */2], Curry._2(Utils.Float[/* * */3], u, sq3), 2.0)), Curry._2(Utils.Float[/* / */2], u, sq3))
                ]
              ];
    
  }
}

function border_walls(size, csize) {
  var res = /* [] */0;
  var u = csize[0] / size;
  for(var x = 0 ,x_finish = size - 1 | 0; x <= x_finish; ++x){
    var match = point_pos(/* tuple */[
          x,
          0
        ], size, csize);
    var fy = match[1];
    var fx = match[0];
    res = /* :: */[
      /* Line */[wall_in_direction(fx, fy, u, /* Yminus */2)],
      /* :: */[
        /* Line */[wall_in_direction(fx, fy, u, /* Zx */4)],
        res
      ]
    ];
  }
  for(var y = 0 ,y_finish = size - 1 | 0; y <= y_finish; ++y){
    var match$1 = point_pos(/* tuple */[
          0,
          y
        ], size, csize);
    var fy$1 = match$1[1];
    var fx$1 = match$1[0];
    res = /* :: */[
      /* Line */[wall_in_direction(fx$1, fy$1, u, /* Xminus */0)],
      /* :: */[
        /* Line */[wall_in_direction(fx$1, fy$1, u, /* Zy */5)],
        res
      ]
    ];
  }
  for(var x$1 = 0 ,x_finish$1 = size - 1 | 0; x$1 <= x_finish$1; ++x$1){
    var y$1 = (size - 1 | 0) - x$1 | 0;
    var match$2 = point_pos(/* tuple */[
          x$1,
          y$1
        ], size, csize);
    var fy$2 = match$2[1];
    var fx$2 = match$2[0];
    res = /* :: */[
      /* Line */[wall_in_direction(fx$2, fy$2, u, /* Yplus */3)],
      /* :: */[
        /* Line */[wall_in_direction(fx$2, fy$2, u, /* Xplus */1)],
        res
      ]
    ];
  }
  return res;
}

function drawable_wall(param, size, csize) {
  var dest = param[1];
  var src = param[0];
  var match = from_vertex(src, size);
  var y = match[1];
  var x = match[0];
  var match$1 = from_vertex(dest, size);
  var u = Curry._2(Utils.Float[/* / */2], csize[0], size);
  var direction = direction_of_points(src, dest, /* tuple */[
        x,
        y
      ], /* tuple */[
        match$1[0],
        match$1[1]
      ]);
  var match$2 = point_pos(/* tuple */[
        x,
        y
      ], size, csize);
  var pts = wall_in_direction(match$2[0], match$2[1], u, direction);
  return /* Line */[pts];
}

exports.vertex_count        = vertex_count;
exports.from_vertex         = from_vertex;
exports.to_vertex           = to_vertex;
exports.maybe_vertex        = maybe_vertex;
exports.optmap              = optmap;
exports.adjacency_list      = adjacency_list;
exports.fi                  = fi;
exports.point_pos           = point_pos;
exports.vertex_pos          = vertex_pos;
exports.direction_of_points = direction_of_points;
exports.sq3                 = sq3;
exports.wall_in_direction   = wall_in_direction;
exports.border_walls        = border_walls;
exports.drawable_wall       = drawable_wall;
/* sq3 Not a pure module */
