// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE
'use strict';

var List                    = require("bs-platform/lib/js/list.js");
var $$Array                 = require("bs-platform/lib/js/array.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Random                  = require("bs-platform/lib/js/random.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Generator               = require("../Types/generator.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function init(size) {
  var start = Random.$$int(size);
  return /* record */[
          /* visited */Caml_array.caml_make_vect(size, 0),
          /* edges */Generator.PairSet[/* empty */0],
          /* frontier : array */[/* tuple */[
              start,
              start
            ]],
          /* step */0
        ];
}

function edges(state) {
  return state[/* edges */1];
}

function visited(state) {
  return state[/* visited */0];
}

function max_age(state) {
  return state[/* step */3];
}

function sortpair(a, b) {
  var match = Caml_obj.caml_greaterthan(a, b);
  if (match !== 0) {
    return /* tuple */[
            b,
            a
          ];
  } else {
    return /* tuple */[
            a,
            b
          ];
  }
}

function step(get_adjacent, state) {
  while(true) {
    var match = state[/* frontier */2];
    if (match.length !== 0) {
      var match$1 = state[/* frontier */2].splice(Random.$$int(state[/* frontier */2].length), 1);
      if (match$1.length !== 1) {
        throw [
              Caml_builtin_exceptions.match_failure,
              [
                "/Users/jared/clone/experiments/maze/src/Algorithms/Random2.re",
                29,
                9
              ]
            ];
      } else {
        var match$2 = match$1[0];
        var dest = match$2[1];
        if (Caml_array.caml_array_get(state[/* visited */0], dest) > 0) {
          continue ;
          
        } else {
          Caml_array.caml_array_set(state[/* visited */0], dest, state[/* step */3] + 1 | 0);
          var others = List.map((function(dest){
              return function (x) {
                return /* tuple */[
                        dest,
                        x
                      ];
              }
              }(dest)), List.filter(function (x) {
                      return +(Caml_array.caml_array_get(state[/* visited */0], x) === 0);
                    })(Curry._1(get_adjacent, dest)));
          return /* record */[
                  /* visited */state[/* visited */0],
                  /* edges */Curry._2(Generator.PairSet[/* add */3], sortpair(match$2[0], dest), state[/* edges */1]),
                  /* frontier */$$Array.append($$Array.of_list(others), state[/* frontier */2]),
                  /* step */state[/* step */3] + 1 | 0
                ];
        }
      }
    } else {
      return state;
    }
  };
}

function finished(state) {
  return Caml_obj.caml_equal(state[/* frontier */2], /* array */[]);
}

function loop_to_end(get_adjacent, _state) {
  while(true) {
    var state = _state;
    if (Caml_obj.caml_equal(state[/* frontier */2], /* array */[])) {
      return state;
    } else {
      _state = step(get_adjacent, state);
      continue ;
      
    }
  };
}

function run(size, get_adjacent) {
  return loop_to_end(get_adjacent, init(size));
}

exports.init        = init;
exports.edges       = edges;
exports.visited     = visited;
exports.max_age     = max_age;
exports.sortpair    = sortpair;
exports.step        = step;
exports.finished    = finished;
exports.loop_to_end = loop_to_end;
exports.run         = run;
/* Generator Not a pure module */
